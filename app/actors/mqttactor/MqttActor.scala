package actors.mqttactor

import akka.actor._
import akka.event.Logging
import org.eclipse.paho.client.mqttv3._
import play.api.libs.json._
import play.Logger
import java.util.UUID
import scala.math.BigInt

case class ChannelFilter(topicFilter: String, qos: Int = 0)

/**
  * A message expected by the MqttActor
  */
trait MqttActorMessage
/**
  * A message expected from the «listner» that alter the state of the actor or
  * publish data on the mqtt bus
  */
trait MqttActorInboundMessage extends MqttActorMessage
/**
  * A message to be returned to the «listner»
  */
trait MqttActorOutboundMessage extends MqttActorMessage
/**
 * Connect to the mqtt bus
 */
case class Connect() extends MqttActorInboundMessage
/**
  * Close the mqtt connection
  */
case class Close() extends MqttActorInboundMessage
/**
  * Disconnect the mqtt client
  */
case class Disconnect(quiesceTimeout: Option[Long]) extends MqttActorInboundMessage
case class Subscribe(channelFilters: Seq[ChannelFilter]) extends MqttActorInboundMessage
case class Unsubscribe(topicFilters: Seq[String]) extends MqttActorInboundMessage
trait PublishMessage extends MqttActorInboundMessage
case class PublishBytes(topic: String, payload: Array[Byte], qos: Int, retained: Boolean) extends PublishMessage
class PublishText(topic: String, payload: String, qos: Int, retained: Boolean) extends PublishBytes(topic, payload.getBytes(), qos, retained)
class PublishJson(topic: String, payload: JsValue, qos: Int, retained: Boolean) extends PublishText(topic, Json.stringify(payload), qos, retained)
case class Publish(topic: String, message: MqttMessage) extends PublishMessage
/**
  * Notify connection lost to the listner
  */
case class ConnectionLost(cause: Throwable) extends MqttActorOutboundMessage
/**
  * Notify a new message to the listner
  */
case class MessageArrived(topic: String, message: MqttMessage) extends MqttActorOutboundMessage
/**
  * Notify a qos 1 or 2 delivery
  */
case class DeliveryComplete(token: IMqttDeliveryToken)

class MqttActor(serverUri: String, clientId: String, persistence: MqttClientPersistence = null)
  extends Actor with ActorLogging
  with MqttCallback {

  val effectiveClientId = if (clientId.isEmpty()) {
    import java.security.SecureRandom
    import java.math.BigInteger
    val autogenerated = new BigInteger(130, new SecureRandom()).mod(BigInteger.TEN.pow(30)).toString(32)
    log.debug(s"Client id was empty. Autogenerated is [$autogenerated]")
    autogenerated
  } else
    clientId

  val mqttClient = new MqttAsyncClient(serverUri, effectiveClientId, persistence)

  mqttClient.setCallback(this)

  override def postStop() {
    if (mqttClient.isConnected()) {
    	mqttClient.disconnect()
    	mqttClient.close()
    }
    super.postStop()
  }
  def connectionLost(cause: Throwable) = context.parent ! ConnectionLost(cause: Throwable)
  def messageArrived(topic: String, message: MqttMessage) = context.parent ! MessageArrived(topic, message)
  def deliveryComplete(token: IMqttDeliveryToken) = context.parent ! DeliveryComplete(token)

  def receive = {
    case Connect() => {
      log.debug("CONNNECTING TO MQTT BUS...")
      mqttClient.connect()
      Thread.sleep(800)
      log.debug("CONNECTED")
    }
    case Close() => mqttClient.close()
    case Disconnect(qTimeout) => qTimeout match {
      case Some(t) => mqttClient.disconnect(t)
      case _       => mqttClient.disconnect()
    }
    case Subscribe(channelFilter) => if (!channelFilter.isEmpty) {
      val topics = channelFilter.map(_.topicFilter)
      val qoss = channelFilter.map(_.qos)
      log.debug(s"SUBSCRIBING TO CHANNEL $channelFilter")
      if (!mqttClient.isConnected()) {
        mqttClient.connect()
        Thread.sleep(500)
      }
      mqttClient.subscribe(topics.toArray, qoss.toArray)
    }
    case Unsubscribe(topicFilters) => if (!topicFilters.isEmpty) {
      mqttClient.unsubscribe(topicFilters.toArray)
    }
    case PublishBytes(topic, payload, qos, retained) => mqttClient.publish(topic, payload, qos, retained)
    case Publish(topic, message)                     => mqttClient.publish(topic, message)
  }
}

